
Content from file: main.c
#include "header.h"
int main(){
    // char date[] = "21 june 2021";
    // int day, year;
    // char month[9];

    // sscanf( date, "%i %s %i", &day, month, &year);
    // printf("The day is %i , the month is %s, the year is %i ", day, month, year);

    char stdout[100];
    s21_sprintf(stdout, "o%d hello%d\n", 1, 2);
    
    printf("%s", stdout);

    


    }



Content from file: header.h
#include <stdio.h>
#include <strings.h>
#include <stdarg.h>
#include <math.h>
typedef struct flags{
    int integer;
    int string;


} flags;

int s21_sprintf(char *str, const char *format, ...);
char* write_string(flags Flags, va_list arg);
char* write_int(flags Flags, va_list arg);
flags parser(const char *format);
char*  concat_type(flags Flags, va_list arg);
char* itoa(int num, char* buffer, int base);

Content from file: ssprintf_ref.c
#include "header.h"
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#define _OPEN_SYS_ITOA_EXT
int s21_sprintf(char *str, const char *format, ...){
    
    va_list arg;
    va_start(arg, format);
    char* tmp=(char*)malloc(sizeof(char*)*2);
    flags Flags;
    while(*format!='\0'){
        printf("here?");

        if(*format=='%'){
           Flags=parser(format); // создаем зануляем и заполняем структуру флаги, идем от процента
           tmp=concat_type(Flags, arg);
           strcat(str, tmp);
        }
           *str=*format;
format++;
str++;        
    
    }
    
     //в arg записывается указатель на первый аргумент из ...

// int x=va_arg(arg, int); //возвращает значение arg(текущий variable argument)
// int y=va_arg(arg, int); //при последующем вызове вернет следующий аргумент
// char* s=va_arg(arg, char*);
// // printf("x=%d", x);
// // printf("y=%d", y);
// // printf("s=%s", s);
   
    va_end(arg);
    
}
void s21_reverse(char *str, int length) {
    int start = 0;
    int end = length - 1;
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}
char* itoa(int num, char* buffer, int base)   
{  
int current = 0;  
if (num == 0) {  
buffer[current++] = '0';  
buffer[current] = '\0';  
return buffer;  
}  
int num_digits = 0;  
if (num < 0) {  
if (base == 10) {  
num_digits ++;  
buffer[current] = '-';  
current ++;  
num *= -1;  
}  
else  
return NULL;  
}  
num_digits += (int)floor(log(num) / log(base)) + 1;  
while (current < num_digits)   
{  
int base_val = (int) pow(base, num_digits-1-current);  
int num_val = num / base_val;  
 char value = num_val + '0';  
buffer[current] = value;  
current ++;  
num -= base_val * num_val;  
}  
buffer[current] = '\0';  
return buffer;  
}  





 char*  concat_type(flags Flags, va_list arg){
    char* add_this;
    if(Flags.integer==1){
       add_this=write_int(Flags, arg);
    }
    else if(Flags.string==1){
        add_this=write_string(Flags, arg);
    }
    return add_this; //мы допишем это в str вместо %d
   }

char* write_int(flags Flags, va_list arg){
    int i=va_arg(arg, int);
    char* x;
    x=itoa(va_arg(arg, int), x, 10);
    itoa(i, x, 10);
return x;

}

char* write_string(flags Flags, va_list arg){
    char* x=va_arg(arg, char*);
return x;

}

    flags parser(const char *format){
        flags Flags={0};
        format++;
        while(*format!=' '){
            printf("here?:");
        switch(*format){
            
        case'd':
            Flags.integer=1;
            break;
        case's':
            Flags.string=1;
            break;  
        default:
            break;  }
            
            format++;
    }
    return Flags;


    }


